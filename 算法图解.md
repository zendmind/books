# 算法图解

## 第一章	算法简介

### 1.1	引言

### 1.2	二分查找

二分查找是一种算法，其输入是一个有序的元素列表。如果查找的元素包含在列表中，二分查找返回其位置；否则返回null。

```python
def binary_search(list, item):
    low = 0
    high = len(list) - 1

    while low < high:
        mid = int((low + high) / 2)
        guess = list[mid]
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None
```

#### 1.2.2	运行时间

简单查找的运行时间为线性时间，二分查找的运行时间为对数时间。

### 1.3	大O表示法

#### 1.3.1	算法的运行时间以不同的速度增加

大O表示法并不表示具体的执行时间，而是让你能够比较操作数，它指出了算法运行时间的增速。

#### 1.3.3	大O表示法指出了最糟情况下的运行时间

#### 1.3.4	一些常见的大O运行时间

- $O(log\,n)$，也叫对数时间，这样的算法包括二分查找
- $O(n)$，也叫线性时间，这样的算法包括简单查找
- $O(n*log\,n)$，这样的算法包括快速排序--一种速度较快的排序算法
- $O(n^2)$，这样的算法包括选择排序--一种速度较慢的排序算法
- $O(n!)$，这样的算法包括旅行商问题的解决方案--一种非常慢的算法

#### 1.3.5	旅行商



## 第二章	选择排序

### 2.1	内存的工作原理

需要将数据存储到内存时，你将请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式--数组和链表。

### 2.2	数组和链表

数组是最基本的数据结构，所开辟的内存空间是连续的，且内存大小一经确定之后便无法再更改，以上两点也成为数组的缺点：浪费内存，缺乏弹性。而也因为开辟的内存空间是连续的，这也成为它的一个优点：查找速度快。数组的另外一个缺点就是：增添和删除的效率低。

链表在某些地方上就和数组相反，存储数据的内存不需要是连续的，链表中的数据可以存储在内存的任何地方。链表的优点为：存储灵活，添加和删除元素十分方便。链表的缺点为：查找元素麻烦。

#### 数组和链表操作的运行时间：

数组：插入	$O(n)$	读取	$O(1)$	删除	$O(n)$

链表：插入	$O(1)$	读取	$O(n)$	删除	$O(1)$

#### 2.3	选择排序

```python
def findsmallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = findsmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr
```



## 第三章	递归

### 3.1	递归

如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。

### 3.2	基线条件和递归条件

每个递归函数都有两部分：基线条件(base case)和递归条件(recursive case)。

### 3.3	栈

#### 3.3.1	调用栈

计算机在内部使用调用栈的栈。调用另外一个函数时，当前函数暂停并处于未完成状态，该函数的所有变量的值都还在内存中。

#### 3.3.2	递归调用栈

使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。



## 第四章	快速排序

### 4.1	分而治之

### 4.2	快速排序

```python
def quicksort(arr):
    if len(arr) < 2:
        return arr
    else:
        pivot = arr[0]
        less = [i for i in arr[1:] if i <= pivot]
        greater = [i for i in arr[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)
    
print(quicksort([5, 3, 6, 2, 10, 1, 4, 7, 8, 9]))
```

